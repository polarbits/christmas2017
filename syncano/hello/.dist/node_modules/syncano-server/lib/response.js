'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _lodash = require('lodash.get');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Unified response helper
 * @property {Function}
 */

var Response = function Response(instance) {
  var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var status = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;
  var mimetype = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'text/plain';
  var headers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

  _classCallCheck(this, Response);

  this._content = content;
  this._status = status;
  this._mimetype = mimetype;
  this._headers = headers;

  var setResponse = instance.setResponse || global.setResponse;
  var HttpResponse = instance.HttpResponse || global.HttpResponse;

  if (this._content) {
    var args = [this._status, this._content, this._mimetype, this._headers];

    if (setResponse === undefined) {
      return;
    }

    setResponse(new (Function.prototype.bind.apply(HttpResponse, [null].concat(args)))());
  }
};

exports.default = function (config) {
  var response = function response(content, status, mimetype, headers) {
    return new Response(config, content, status, mimetype, headers);
  };

  var responses = (0, _lodash2.default)(config, 'meta.metadata.response', {});

  mapYamlResponsesToMethods(response, responses, config);

  response.header = function (key, value) {
    response._headers = _extends({}, response._headers, _defineProperty({}, key, value));

    return response;
  };

  response.json = function (content) {
    var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;
    return new Response(config, JSON.stringify(content), status, 'application/json', response._headers);
  };

  return response;
};

function mapYamlResponsesToMethods(response, responses, config) {
  Object.keys(responses).forEach(function (name) {
    var _responses$name = responses[name],
        _responses$name$mimet = _responses$name.mimetype,
        mimetype = _responses$name$mimet === undefined ? 'application/json' : _responses$name$mimet,
        _responses$name$exit_ = _responses$name.exit_code,
        status = _responses$name$exit_ === undefined ? 200 : _responses$name$exit_;

    var isJSON = mimetype === 'application/json';

    response[name] = function (content) {
      return new Response(config, isJSON ? JSON.stringify(content) : content, status, mimetype, response._headers);
    };
  });
}
module.exports = exports['default'];